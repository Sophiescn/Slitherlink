"""fonction pour le solver"""import doctestimport copyimport fct_acces as accesimport fct_victoire as victoireimport fct_interface as interfaceimport fct_clicks as clicksfrom time import sleepimport fltk    """Première version du solver"""def indices_ok(jeu, infos, etat, sommets):    """    La fonction prend les différents dictionaires du jeut et verifie si les     cases adjacentes au segment on des indices qui peuvent encore etre satisfait.        Parameters    ----------    jeu : dictionaire        dictionnaire du jeu (contien la liste des indices).    infos : dictionaire        dictionaire des information sur les dimension du jeu.            etat : dictionaire        dictionaire des segments tracés.    sommets : tuple        liste de deux coordonnees.    Returns    -------    True si on peut tracé le segment des deux sommets et sinon False.        >>> indices = [[None, None, None, None, 0, None], [3, 3, None, None, 1, None], [None, None, 1, 2, None]]    >>> jeu = {'indices': indices}    >>> infos = {'hauteur': 3, 'largeur':6}    >>> indices_ok(jeu, infos, {}, ((2, 2), (2, 1)))    True    >>> indices_ok(jeu, infos, {}, ((0, 4), (0, 5)))    False    >>> indices_ok(jeu, infos, {}, ((0, 2), (0, 3)))    True    """    sommet1, sommet2 = sommets    # on prend le plus petit des sommets car il correspond a une des case     # que le segment va traverser    sommet = min(sommet1, sommet2)    x, y = sommet    if sommet1[0] == sommet2[0]:        # on regarde la case au dessus et en dessous        case1 = (x-1, y)        case2 = (x, y)        if acces.statut_case(jeu['indices'], etat, case1) == 1 or acces.statut_case(jeu['indices'], etat, case1) == None:            # la première case ne dérange pas             if case2[0] == infos['hauteur']: # la case n'est pas dans la grille                return True            if acces.statut_case(jeu['indices'], etat, case2) == 1 or acces.statut_case(jeu['indices'], etat, case2) == None:                # la case en bas ne déarnge pas                 return True        if case1[0] == -1: # on sort en haut             if case2[0] == infos['hauteur']:                return True            if acces.statut_case(jeu['indices'], etat, case2) == 1 or acces.statut_case(jeu['indices'], etat, case2) == None:                return True        return False        if sommet1[1] == sommet2[1]:        # on regarde la case a gauche et a droite        case1 = (x, y - 1)        case2 = (x, y)        if acces.statut_case(jeu['indices'], etat, case1) == 1 or acces.statut_case(jeu['indices'], etat, case1) == None:            # la case a gauche ne dérange pas             if case2[1] == infos['largeur']:# la case n'est pas dans la grille                return True            if acces.statut_case(jeu['indices'], etat, case2) == 1 or acces.statut_case(jeu['indices'], etat, case2) == None:                # la case de droite ne dérange pas                 return True        elif case1[1] == -1:# la case a gauche n'est pas dans la grille             if case2[1] == infos['largeur']:                return True            if acces.statut_case(jeu['indices'], etat, case2) == 1 or acces.statut_case(jeu['indices'], etat, case2) == None:                return True        return False    def solver(jeu, infos, sommet, etat={}):    """    Le solver resout les grilles.        Parameters    ----------    jeu : dictionaire        dictionnaire du jeu (contien la liste des indices).    infos : dictionaire        dictionaire des information sur les dimension du jeu.             sommet : tuple        liste de deux coordonnees.             etat : dictionaire        dictionaire des segments tracés.    Returns    -------    affiche la solutions si elle existe return False sinon.    """    if len(acces.segments_traces(etat, sommet)) == 2:        # si deux segment partent d'un sommet on a une boucle         if victoire.indices_satisfaits(jeu['indices'], etat):            interface.affiche_solution(etat, jeu, infos)            return True        return False    elif len(acces.segments_traces(etat, sommet)) > 2:        # plus de deux segment on a un embranchement        return False     else:        x, y = sommet                if x > 0 and ((x-1, y), sommet) not in etat:            # pour monter            sommet2 = (x-1, y)            if indices_ok(jeu, infos, etat, (sommet2, sommet)):                etat[(sommet2, sommet)] = 1                if solver(jeu, infos, sommet2, etat):                    return True                else:                    etat.pop((sommet2, sommet))                                                if y < infos['largeur']and (sommet, (x, y+1)) not in etat:            # a droitte            sommet2 = (x, y+1)            if indices_ok(jeu, infos, etat, (sommet, sommet2)):                etat[(sommet, sommet2)] = 1                if solver(jeu, infos, sommet2, etat):                    return True                else:                    etat.pop((sommet, sommet2))                                    if x < infos['hauteur'] and (sommet, (x+1, y)) not in etat:            # en bas             sommet2 = (x+1, y)            if indices_ok(jeu, infos, etat, (sommet2, sommet)):                etat[(sommet, sommet2)] = 1                if solver(jeu, infos, sommet2, etat):                    return True                else:                    etat.pop((sommet, sommet2))                                                if y > 0 and((x, y-1), sommet) not in etat:            # a gauche            sommet2 = (x, y-1)            if indices_ok(jeu, infos, etat, (sommet2, sommet)):                etat[(sommet2, sommet)] = 1                if solver(jeu, infos, sommet2, etat):                    return True                else:                    etat.pop((sommet2, sommet))                         return False"""Deuxième version du solver"""def avance(bouton):    """    la fonction renvoi 1 si le mode du solver est 'lent', -1 s'il est 'rapide'        Parameters    ----------    bouton : string        'lent' ou 'rapide' (mode du solver)            Return    -------    1 si on est en mode lent    -1 sinon    """    if bouton == 'lent':        return 1    else:        return -1            def definie_temps(bouton, jeu, infos, trucs):    """    La fonction revoie la vitesse à laquelle le solver doit aller.        Parameters    ----------    bouton : string        'lent' ou 'rapide' (mode du solver)    jeu : dictionaire        dictionaire du jeu     infos : dictionaire        dictionnaire des informations de la grille de jeu    trucs : tuple        positions et boutons (positions des boutons et les coordonnées de leur forme)            Return    -------    0.5 si on est en mode lent    0 sinon    """        bouton = avance(bouton)    if bouton > 0:        return 0.5    else:        return 0def solver2(jeu, infos, sommet, trucs, bouton, etat={}):# avec affichage progressif     """    La fonction resout la une grille et affcihe chaque segment tracé ou retiré.    La fonction ressemble fortement à solver.         Parameters    ----------    jeu : dictionaire        dictionaire du jeu     infos : dictionaire        dictionnaire des informations de la grille de jeu    sommet : tuple        couple de coordonées    trucs : tuple        positions et boutons (positions des boutons et les coordonnées de leur forme)    bouton : string        'lent' ou 'rapide' (mode du solver)                    Return    -------    True s'il existe une solution a la grille    False sinon    """    t = definie_temps(bouton, jeu, infos, trucs)    sleep(t)    interface.affiche_solution(etat, jeu, infos, trucs[0], trucs[1])        if len(acces.segments_traces(etat, sommet)) == 2:        if victoire.indices_satisfaits(jeu['indices'], etat):            interface.affiche_solution(etat, jeu, infos)            return True        return False    elif len(acces.segments_traces(etat, sommet)) > 2:        return False     else:        x, y = sommet                if x > 0 and ((x-1, y), sommet) not in etat:            sommet2 = (x-1, y)            if indices_ok(jeu, infos, etat, (sommet2, sommet)):                etat[(sommet2, sommet)] = 1                if solver2(jeu, infos, sommet2, trucs, bouton, etat):                    return True                else:                    etat.pop((sommet2, sommet))                    sleep(t)                    interface.affiche_solution(etat, jeu, infos, trucs[0], trucs[1])                            if y < infos['largeur']and (sommet, (x, y+1)) not in etat:            sommet2 = (x, y+1)            if indices_ok(jeu, infos, etat, (sommet, sommet2)):                etat[(sommet, sommet2)] = 1                if solver2(jeu, infos, sommet2, trucs, bouton, etat):                    return True                else:                    etat.pop((sommet, sommet2))                    sleep(t)                    interface.affiche_solution(etat, jeu, infos, trucs[0], trucs[1])                if x < infos['hauteur'] and (sommet, (x+1, y)) not in etat:            sommet2 = (x+1, y)            if indices_ok(jeu, infos, etat, (sommet2, sommet)):                etat[(sommet, sommet2)] = 1                if solver2(jeu, infos, sommet2, trucs, bouton, etat):                    return True                else:                    etat.pop((sommet, sommet2))                    sleep(t)                    interface.affiche_solution(etat, jeu, infos, trucs[0], trucs[1])                            if y > 0 and((x, y-1), sommet) not in etat:            sommet2 = (x, y-1)            if indices_ok(jeu, infos, etat, (sommet2, sommet)):                etat[(sommet2, sommet)] = 1                if solver2(jeu, infos, sommet2, trucs, bouton, etat):                    return True                else:                    etat.pop((sommet2, sommet))                     sleep(t)                    interface.affiche_solution(etat, jeu, infos, trucs[0], trucs[1])        return False    def maj_positions_boutons(positions, boutons,  chaine):    """    La fonction met a jour les boutons que l'on affiche à l'écrant.    Parameters    ----------    positions : dictionaire        dictionaire contenant les boutons des modes du solver avec leur position.    boutons : dictionaire        dictionaire contenant les boutons des modes du solver avec les points qui les forment.    chaine : string        mode choisi.    Returns    -------    d_positions : dictionaire        nouveau dictionaire avec seulement un bouton.    d_boutons : dictionaire        nouveau dictionaire avec seulement un bouton.    """    # on copy les dictionaire pour ne pas effacer leur clés définitivement     d_boutons = copy.deepcopy(boutons)    d_positions = copy.deepcopy(positions)        if chaine == 'rapide':        for cle in boutons:            # on supprime toute les clés différente de 'rapide'            if cle != 'rapide':                d_boutons.pop(cle)        for cle in positions:            if cle != 'rapide':                d_positions.pop(cle)    elif chaine == 'lent':        # on supprime toute les clés différente de 'lent'        for cle in boutons:            if cle != 'lent':                d_boutons.pop(cle)        for cle in positions:            if cle != 'lent':                d_positions.pop(cle)    return d_positions, d_boutons    def lance_solver(jeu, infos):    """    La fonction determine quel solver il faut utiliser en fonction de celui que le     joueur a choisit.    Parameters    ----------    jeu : dictionaire        dictionaire du jeu     infos : dictionaire        dictionnaire des informations de la grille de jeu    Returns    -------    True s'il existe une solution     False sinon    """    bouton, positions, boutons = interface.choix_solver(jeu, infos)    # on determine le sommet de départ du solver    sommet = acces.premier_sommet(jeu)    # on réinitialise etat a vide car les valeur du dictionaire se conservent d'une partie a l'autre    etat = {}        if bouton == 'solver':        solution = solver(jeu, infos, sommet[0], etat)        if not solution: # il n'y a pas de solution a partir de ce sommet            return False        return True        elif bouton == 'rapide':        trucs = maj_positions_boutons(positions, boutons, 'rapide')        if not solver2(jeu, infos, sommet[0], trucs, 'rapide', etat):            if not solver2(jeu, infos, sommet[1], trucs, 'rapide', etat):                return False        return True        elif bouton == 'lent':        trucs = maj_positions_boutons(positions, boutons, 'lent')        if not solver2(jeu, infos, sommet[0], trucs, 'lent', etat):            if not solver2(jeu, infos, sommet[0], trucs, 'lent', etat):                return False        return True    #doctest.testmod(verbose=True)